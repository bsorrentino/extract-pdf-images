{"version":3,"sources":["pdf2md.global.ts","pdf2md.image.ts","pdf2md.model.ts","pdf2md.page.ts","pdf2md.markdown.ts","pdf2md.main.ts","index.ts"],"names":[],"mappings":"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","file":"index.js","sourceRoot":"../src","sourcesContent":["import assert = require('assert')\nimport path from 'path'\nimport fs from 'fs'\nimport { promisify } from 'util'\n\nconst checkFileExistsAsync = promisify(fs.access)\nconst readFileAsync = promisify(fs.readFile)\nconst writeFileAsync = promisify(fs.writeFile)\n\ninterface Font {\n    name: string | null\n}\n\ntype FontStat = Font & { occurrence: number }\n\nexport interface Stats {\n    mostUsedFont: string // fontId\n    mostUsedTextHeight: number\n    maxTextHeight: number\n    textHeigths: Array<number>\n    maxHeightFont: string | null\n    mostUsedTextDistanceY: number\n}\n\nclass Globals {\n\n    private _fontMap = new Map<string, FontStat>()\n    private _textHeights = new Map<number, number>()\n    private _imageUrlPrefix = process.env['IMAGE_URL'] || ''\n    private _options = {\n        filler: false,\n        debug: false,\n        stats: false\n    }\n\n    outDir: string\n\n    get options() { return this._options }\n\n    /**\n     * \n     * @param fontId \n     * @param font \n     */\n    addFont(fontId: string, font: Font) {\n\n        assert(font, `font ${fontId} is not valid ${font}`)\n\n        let value = this._fontMap.get(fontId) || { ...font, occurrence: 0 }\n\n        value.occurrence++\n\n        this._fontMap.set(fontId, value)\n\n    }\n\n    /**\n     * \n     * @param fontId \n     */\n    getFont(fontId: string): Font | undefined {\n        return this._fontMap.get(fontId) as Font\n    }\n\n    /**\n     * \n     * @param fontId \n     */\n    getFontIdByName(name: string): string | undefined {\n        for( const [k,f] of this._fontMap.entries() ) \n            if( f.name == name ) \n                return k\n    }\n\n    /**\n     * \n     * @param height \n     */\n    addTextHeight(height: number) {\n\n        let occurrence = this._textHeights.get(height) || 0\n\n        this._textHeights.set(height, ++occurrence)\n\n    }\n\n    private _stats: Stats | null = null\n\n    /**\n     * \n     */\n    get stats(): Stats {\n\n        if (!this._stats) {\n            const calculateMostUsedFont = () => {\n                const [k, _] = Array.from(this._fontMap.entries()).reduce(([k1, v1], [k, v]) => (v.occurrence > v1.occurrence) ? [k, v] : [k1, v1], ['', { occurrence: 0 }])\n                return k\n            }\n\n            const calculateMaxTextHeight = () =>\n                Array.from(this._textHeights.keys()).reduce((result, h) => (h > result) ? h : result)\n\n\n            const calculateMostUsedTextHeight = () => {\n                const [k, _] = Array.from(this._textHeights.entries()).reduce(([k1, v1], [k, v]) => (v > v1) ? [k, v] : [k1, v1], [0, -1])\n                return k\n            }\n\n            this._stats = {\n                maxTextHeight: calculateMaxTextHeight(),\n                maxHeightFont: null,\n                mostUsedFont: calculateMostUsedFont(),\n                mostUsedTextHeight: calculateMostUsedTextHeight(),\n                textHeigths: Array.from(this._textHeights.keys()).sort((a, b) => b - a),\n                mostUsedTextDistanceY: -1,\n            }\n        }\n\n        return this._stats\n\n    }\n\n\n    /**\n     * \n     * @param fontsFile \n     * @param globals \n     */\n    async loadLocalFonts(fontsFile: string) {\n\n        try {\n            await checkFileExistsAsync(fontsFile)\n        }\n        catch (e) {\n            console.warn(`WARN: file ${fontsFile} doesn't exists!`)\n            return\n        }\n\n        try {\n            const contents = await readFileAsync(fontsFile)\n\n            const fonts: { [name: string]: Font } = JSON.parse(contents.toString())\n\n            Object.entries(fonts).forEach(([k, v]) => this.addFont(k, v))\n\n        }\n        catch (e) {\n            console.warn(`WARN: error loading and evaluating ${fontsFile}! - ${e.message}`)\n        }\n    }\n\n    /**\n     * \n     * @param fontMap \n     */\n    async saveFonts(fontsFile: string) {\n\n        try {\n            await checkFileExistsAsync(fontsFile)\n            console.warn(`WARN: file ${fontsFile} already exists!`)\n            return\n        }\n        catch (e) {\n            // correct file doesn't exists\n        }\n\n        try {\n\n            const init:{ [fontId:string]:FontStat } = {}\n\n            const contents = Array.from(this._fontMap.entries())\n                .sort( (e1,e2) => e1[1].occurrence - e2[1].occurrence )\n                .reduce( ( result, e) => { result[ e[0] ] = e[1]; return result } , init )\n            \n            await writeFileAsync(fontsFile, JSON.stringify(contents) )\n\n        }\n        catch (e) {\n            console.warn(`WARN: error writing ${fontsFile}! - ${e.message}`)\n        }\n    }\n\n    get imageUrlPrefix() { \n        // console.log( `imageUrlPrefix ${this._imageUrlPrefix}`)\n        return this._imageUrlPrefix \n    }\n    \n    set imageUrlPrefix( value:string ) {\n        if( !value || value.trim().length===0) return \n\n        this._imageUrlPrefix = value.endsWith('/') ? value : value.concat('/')\n    }\n\n    constructor() {\n        this.outDir = path.join(process.cwd(), 'out')\n    }\n\n    consoleLog() {\n\n\n        const log = [ { ...this.stats, textHeigths: JSON.stringify( this.stats.textHeigths) } ]\n\n        console.table( log )\n        \n    }\n}\n\nexport const globals = new Globals()","import { createCanvas } from \"canvas\"\nimport { assert } from \"console\"\nimport fs from \"fs\"\nimport path from 'path'\nimport { promisify } from 'util'\nimport Jimp from 'jimp'\nimport { PDFImage, PDFPageProxy } from \"pdfjs-dist\"\nimport { globals } from \"./pdf2md.global\"\nimport { type } from \"os\"\n\nenum PDFImageKind {\n    GRAYSCALE_1BPP = 1,\n    RGB_24BPP =  2,\n    RGBA_32BPP = 3\n}\n\nconst writeFileAsync = promisify( fs.writeFile )\n\ntype ImageHash = string\ntype ImageName  = string\n\nconst imagesCache = new Map<ImageHash,ImageName>();\n\n/**\n * \n * @param img \n * @param name \n */\nexport async function writePageImageOrReuseOneFromCache(img:PDFImage, name:ImageName):Promise<ImageName> {\n\n    //console.log( `image ${name} - kind: ${img.kind}`)\n    let bytesPerPixel = 0 \n    switch( img.kind ) {\n      case PDFImageKind.RGB_24BPP:\n        bytesPerPixel = 3\n        break\n      case PDFImageKind.RGBA_32BPP:\n        bytesPerPixel = 4\n        break\n      case PDFImageKind.GRAYSCALE_1BPP:\n        assert( `kind ${img.kind} is not supported yet!`)\n        bytesPerPixel = 1\n        break\n      default:\n        assert( `kind ${img.kind} is not supported at all!`)\n        break\n\n    }\n\n    const jimg = new Jimp(img.width, img.height)\n    \n    const byteWidth = (img.width*bytesPerPixel)\n\n    for (var x=0; x<img.width; x++) {\n      for (var y=0; y<img.height; y++) {\n\n          const index = (y * byteWidth) + (x * bytesPerPixel);\n          const r = img.data[index];\n          const g = img.data[index+1];\n          const b = img.data[index+2];    \n          const a = bytesPerPixel == 3 ? 255 : img.data[index+3]\n\n          //const num = (r*256) + (g*256*256) + (b*256*256*256) + a;\n\n          const num = Jimp.rgbaToInt( r, g, b, a)\n          jimg.setPixelColor(num, x, y);\n          \n      }\n    }\n\n    const imageHash = jimg.hash();\n    let result = imagesCache.get( imageHash );\n\n    if( !result ) {\n      jimg.write(path.join(globals.outDir, `${name}.png`))\n      imagesCache.set( imageHash, name );\n      result = name  \n    }\n\n    return result\n  \n  }\n  \n  interface CanvasObject  { \n    width:number\n    height:number\n    toBuffer():Buffer \n  } \n  \n  type CanvasContext2D = any\n  \n  type CanvasAndContext = {\n    canvas: CanvasObject,\n    context: CanvasContext2D,\n  }\n  \n  class NodeCanvasFactory {\n  \n    create(width:number, height:number):CanvasAndContext {\n      assert(width > 0 && height > 0, \"Invalid canvas size\");\n      var canvas = createCanvas(width, height);\n      var context = canvas.getContext(\"2d\");\n      return {\n        canvas: canvas,\n        context: context,\n      };\n    }\n  \n    reset(canvasAndContext:CanvasAndContext, width:number, height:number) {\n      assert(canvasAndContext.canvas, \"Canvas is not specified\");\n      assert(width > 0 && height > 0, \"Invalid canvas size\");\n      canvasAndContext.canvas.width = width;\n      canvasAndContext.canvas.height = height;\n    }\n  \n    destroy(canvasAndContext:CanvasAndContext) {\n      assert(canvasAndContext.canvas, \"Canvas is not specified\");\n  \n      // Zeroing the width and height cause Firefox to release graphics\n      // resources immediately, which can greatly reduce memory consumption.\n      canvasAndContext.canvas.width = 0;\n      canvasAndContext.canvas.height = 0;\n      //canvasAndContext.canvas = null;\n      //canvasAndContext.context = null;\n    }\n  }\n  \n  /**\n   * \n   * @param page \n   */\n  export async function writePageAsImage( page:PDFPageProxy ) {\n        // Render the page on a Node canvas with 100% scale.\n        const viewport = page.getViewport({ scale: 1.0 });\n      \n        const canvasFactory = new NodeCanvasFactory();\n        \n        const canvasAndContext = canvasFactory.create(\n          viewport.width,\n          viewport.height\n        );\n  \n        const renderContext = {\n          canvasContext: canvasAndContext.context,\n          viewport: viewport,\n          canvasFactory: canvasFactory,\n        };\n  \n        await page.render(renderContext).promise;\n        \n        const content = canvasAndContext.canvas.toBuffer();\n        \n        \n        //console.dir( page )\n        await writeFileAsync( path.join( globals.outDir,  `page-${page.pageNumber}.png`), content )  \n  }\n  ","import { globals } from \"./pdf2md.global\"\n\n\nexport interface Font {\n    name: string | null\n}\n\nexport interface Rect {\n    x: number\n    y: number\n    width: number\n    height: number\n}\n\nexport interface Image extends Rect {\n    url: string\n}\n\nexport interface Word extends Rect {\n    text: string\n    font: string\n\n}\n\nexport interface ItemTransformer<T> {\n    (value: T): T\n}\n\ntype TextTransformer = ItemTransformer<string>\n\nconst FILLER = ' ¶ '\n\nexport class EnhancedWord implements Word {\n    x: number\n    y: number\n    width: number\n    height: number\n    text: string\n    font: string\n\n    private _transformer?: TextTransformer\n\n    constructor(w: Word) {\n        this.x = w.x\n        this.y = w.y\n        this.width = w.width\n        this.height = w.height\n        this.text = w.text\n        this.font = w.font\n    }\n   \n    appendWord(w: Word, isLastWord:boolean ) {\n\n        let result = false\n        const endX = this.x + this.width\n\n        const canConcatFilter = (endX < w.x)\n        const canAppendWord = this.height === w.height && this.font === w.font\n        const fillerWidth = w.x - endX    \n\n        const isWordTextBlank = w.text.trim().length === 0\n\n        if (canAppendWord) {\n\n            if( canConcatFilter && !isWordTextBlank && globals.options.filler ) {\n                this.text += FILLER.concat(w.text)\n                this.width += w.width + fillerWidth    \n            }\n            else {\n                this.text += w.text\n                this.width += w.width          \n            }\n            result = true  \n        }     \n        else if( isLastWord && canConcatFilter && !isWordTextBlank && globals.options.filler)  {\n            this.text += FILLER.concat(w.text)\n            this.width += w.width + fillerWidth    \n        }\n\n        return result\n    }\n\n    addTransformer(transformer: TextTransformer) {\n        if (this._transformer) return false // GUARD\n\n        this._transformer = transformer\n\n        ////////////////////////////////////\n        // SUPPORT TRANSFORMER DEBUG\n        ////////////////////////////////////\n        // this._transformer = ( text:string ) => {\n        //     console.log( `transforming text ${text}`)\n        //     const result = transformer( text )\n        //     console.log( `transform text ${text} to ${result}`)\n        //     return result   \n        // }\n\n        ////////////////////////////////////\n        // SUPPORT TRANSFORMER CHAIN\n        ////////////////////////////////////\n\n        // const prev = this._transformer\n        // this._transformer =  ( prev ) ?\n        //     ( text:string ) => transformer(prev(text)) :\n        //     transformer\n        \n    }\n    \n    toMarkdown() {\n        const result = (this._transformer) ? \n                    this._transformer(this.text) : this.text\n\n        return (result && globals.options.debug) ? `<!--${this.font}-->${result}` : result\n    }\n\n}\n\n\n\n","import assert from \"assert\";\nimport { OPS, PDFImage, PDFPageProxy, Util } from \"pdfjs-dist\";\nimport { globals } from \"./pdf2md.global\";\nimport { writePageImageOrReuseOneFromCache } from \"./pdf2md.image\";\nimport { EnhancedWord, Rect, Word, Image, Font } from \"./pdf2md.model\";\n\ntype TransformationMatrix = [\n    scalex: number,\n    skevX: number,\n    skevY: number,\n    scaleY: number,\n    transformX: number,\n    transformY: number]\n\n\ntype ConsoleFormat = {\n    x?: number\n    y?: number\n    width?: number\n    height?: number\n    image?: string\n    font?: string\n    text?: string\n}\n\nclass ConsoleOutput {\n\n    lines = Array<ConsoleFormat>()\n\n    // private ellipsisText(text: string, maxChars: number) {\n\n    //     const regex = new RegExp(`(.{${maxChars}})..+`)\n\n    //     return text.replace(regex, \"$1…\")\n    // }\n\n    appendRow(row: Row) {\n\n        if (row.containsImages) {\n            \n            const v = row.images?.map( (img, i) => {\n\n                this.lines.push({ \n                    y: img?.y, \n                    width: img?.width, \n                    x: img?.x,  \n                    height: img?.height, \n                    image: img?.url || 'undefined' \n                })\n\n            })\n        }\n        if (row.containsWords) {\n            const e = row.enhancedText\n\n            const formats = e.map((etext, i) => {\n                //const text = this.ellipsisText(etext.text, 100)\n                const text = etext.text \n                const common = { height: etext.height, image: undefined, text: text, font: etext.font }\n                if (i == 0) {\n                    return {  y: etext.y, width: etext.width, x: etext.x, ...common }\n                }\n                return { width: etext.width, x: etext.x, ...common }\n            })\n\n            this.lines.push(...formats)\n\n        }\n\n    }\n\n}\n\n\nexport class Row {\n    y: number\n    private _images?: Array<Image>\n    private _words?: Array<Word>\n    private _etextArray?:Array<EnhancedWord>\n\n    constructor(args: { y: number , words?: Array<Word>, images?: Array<Image> }) {\n        this.y = args.y\n        this._words = args.words\n        this._images = args.images\n\n        this._updateEnhancedText()\n    }\n\n    get containsWords() { return this._words !== undefined }\n\n    addWord( w:Word ) {\n        this._words?.push( w )\n        this._updateEnhancedText()\n    }\n\n    get containsImages() { return this._images !== undefined }\n\n    addImage( img:Image ) {\n        this._images?.push( img )\n    }\n\n    private _updateEnhancedText() {  \n        if( !this._words || this._words.length == 0) return // GUARD\n        \n        const init = {\n            lastIndex: -1,\n            result: Array<EnhancedWord>()\n        }\n\n        this._etextArray =  this._words.reduce((state, w, index, words ) => {\n\n            if (state.lastIndex < 0) {\n                state.result.push(new EnhancedWord(w))\n                state.lastIndex = 0\n            }\n            else {\n                const isLastWord = index === words.length-1 \n\n                const enhancedText = state.result[state.lastIndex]\n\n                if (!enhancedText.appendWord(w, isLastWord)) {\n                    state.result.push(new EnhancedWord(w))\n                    state.lastIndex++    \n                }\n\n            }\n            return state\n\n        }, init).result\n    }\n \n    get enhancedText() { \n        //this._updateEnhancedText()        \n        return this._etextArray! \n    }\n\n    get images() { return this._images }\n\n    containsTextWithHeight( height:number ) {\n        //this._updateEnhancedText()\n        assert(this._etextArray, 'text array is undefined!')\n        return this._etextArray.findIndex( etext => etext.height == height ) >= 0\n    }\n}\n\n/**\n * \n */\nexport class Page {\n    rows = Array<Row>()\n\n    process(arg: Rect) {\n        if ('text' in arg) {\n            this.processWord(arg as Word)\n        }\n        if ('url' in arg) {\n            this.processImage(arg as Image)\n        }\n        return this\n    }\n\n    private processImage(img: Image) {\n        let si = this.rows.findIndex(row => row.y == img.y)\n        //assert(si < 0, `row ${si} already exists! it is not possible add an image`)\n        let row: Row\n        if (si < 0) {\n            row = new Row({ y: img.y, images: Array<Image>() })\n            this.rows.push(row)\n        }\n        else {\n            row = this.rows[si]\n        }\n        row.addImage(img)\n        return this\n    }\n\n    private processWord(w: Word) {\n        let si = this.rows.findIndex(row => row.y === w.y)\n        let row: Row\n        if (si < 0) {\n            row = new Row({ y: w.y, words: Array<Word>() })\n            this.rows.push(row)\n        }\n        else {\n            row = this.rows[si]\n        }\n\n        //assert( s.containsWords, `row ${si} not containing words! is it contain image?` )\n        if (row.containsWords) {\n            row.addWord(w)\n        }\n        return this\n    }\n\n    insertRow( atIndex:number, w:Word ) {\n\n        if( atIndex < 0 || atIndex >= this.rows.length) throw `atIndex ${atIndex} is out of range!`\n\n        const row = new Row({ y: w.y, words: [w] })\n\n        this.rows.splice( atIndex, 0, row)\n    }\n\n    /**\n     * \n     */\n    consoleLog() {\n        // Debug\n        const consoleOutput = new ConsoleOutput()\n        this.rows.forEach(row => consoleOutput.appendRow(row))\n        console.table(consoleOutput.lines)\n    }\n\n}\n\nfunction mergeItemsArray(a: Array<Rect>, b: Array<Rect>): Array<Rect> {\n    return a.concat(b)\n}\n\n// A page which holds PageItems displayable via PdfPageView\nexport async function processPage(proxy: PDFPageProxy) {\n\n    const ops = await proxy.getOperatorList()\n\n    // console.log( 'transform', OPS.transform )\n\n    let imageMatrix: TransformationMatrix | null = null\n\n    const images = Array<Image>()\n\n    ops.fnArray.forEach(async (fn, j) => {\n\n        // const s = Object.entries(OPS).find( ([_,v]) => v === fn )\n        // if( s ) console.log( `Operation: ${fn}: ${s[0]} at ${j}` )\n\n        let args = ops.argsArray[j]\n\n        switch (fn) {\n            case OPS.setFont:\n\n                const fontId = args[0];\n\n                let font: Font | null\n                try {\n                    font = proxy.objs.get<Font>(fontId)\n                    if (font)\n                        globals.addFont(fontId, font)\n                }\n                catch (e) {\n                    //console.debug(e.message)\n                    globals.addFont(fontId, { name: '' })\n                }\n\n                break;\n            // @see \n            // https://github.com/mozilla/pdf.js/issues/10498\n            // https://github.com/TomasHubelbauer/globus/blob/master/index.mjs#L63\n            //\n            case OPS.transform:\n                assert(j < ops.argsArray.length, `index ${j} exceed the argsArray size ${ops.argsArray.length}`)\n\n                imageMatrix = <TransformationMatrix>args\n                //console.log( imageMatrix )  \n\n                break;\n            case OPS.paintJpegXObject:\n            case OPS.paintImageXObject:\n\n                const position = { x: 0, y: 0 }\n\n                if (imageMatrix) {\n                    position.x = imageMatrix ? Math.round(imageMatrix[4]) : 0\n                    position.y = imageMatrix ? Math.round(imageMatrix[5]) : 0\n                }\n\n                // console.log( 'image position', position )\n\n                const imageName = args[0];\n\n                try {\n                    const img = proxy.objs.get<PDFImage>(imageName);\n\n                    // console.log( `${position.x},${position.y},${img?.width},${img?.height}` )\n                    if (img) {\n                        const imageNameUsed = await writePageImageOrReuseOneFromCache(img, imageName)\n    \n                        images.push({\n                            y: position.y,\n                            x: position.x,\n                            width: img.width,\n                            height: img.height,\n                            url: imageNameUsed\n                        })\n                    }\n    \n                }\n                catch( e ) { \n                    console.warn( `image name ${imageName} not found!` )\n                }\n\n                imageMatrix = null\n                break\n            default:\n                break;\n        }\n\n    })\n\n    const scale = 1.0;\n\n    const viewport = proxy.getViewport({ scale: scale });\n\n    const textContent = await proxy.getTextContent()\n\n    const words = textContent.items.map(item => {\n\n        const tx = Util.transform(viewport.transform, item.transform)\n\n        const fontHeight = Math.sqrt((tx[2] * tx[2]) + (tx[3] * tx[3]))\n\n        const dividedHeight = item.height / fontHeight;\n\n        const textRect = {\n            x: Math.round(item.transform[4]),\n            y: Math.round(item.transform[5]),\n            width: Math.round(item.width),\n            height: Math.round(dividedHeight <= 1 ? item.height : dividedHeight)\n        }\n\n        //console.log( { text: item.str, ...textRect } )\n        globals.addTextHeight(textRect.height)\n\n        return <Word>{ text: item.str, font: item.fontName, ...textRect }\n\n    });\n\n    const items = mergeItemsArray(words, images)\n\n    const page = items.sort((a, b) => {\n        const r = b.y - a.y\n        return (r === 0) ? a.x - b.x : r\n    })\n    .reduce((page, item) => page.process(item), new Page())\n\n\n    return page\n}\n\n\n","import assert = require('assert')\n\nimport { Enumify } from \"enumify\";\nimport { globals } from './pdf2md.global';\nimport { EnhancedWord, ItemTransformer, Word } from \"./pdf2md.model\";\nimport { Page, Row } from \"./pdf2md.page\";\n\n\ntype ToText = ItemTransformer<string>\n\n// An Markdown block\nclass BlockType extends Enumify {\n\n    toText: ToText\n\n    constructor(options: {\n        toText: ToText\n    }) {\n        super()\n        this.toText = options.toText\n    }\n\n    static H1 = new BlockType({\n        toText: (block) => `# ${block}`\n    })\n    static H2 = new BlockType({\n        toText: (block) => `## ${block}`\n    })\n    static H3 = new BlockType({\n        toText: (block) => `### ${block}`\n    })\n    static H4 = new BlockType({\n        toText: (block) => `#### ${block}`\n\n    })\n    static H5 = new BlockType({\n        toText: (block) => `##### ${block}`\n    })\n    static H6 = new BlockType({\n        toText: (block) => `###### ${block}`\n    })\n    static OVERFLOW = new BlockType({\n        toText: (block) => block\n    })\n    /*\n        static TOC = new BlockType( {\n            mergeToBlock: true,\n            toText(block:LineItemBlock) {\n                return linesToText(block.items, true);\n            }\n        })\n        static FOOTNOTES = new BlockType({\n            mergeToBlock: true,\n            mergeFollowingNonTypedItems: true,\n            toText(block:LineItemBlock) {\n                return linesToText(block.items, false);\n            }\n        })\n    \n        static CODE = new BlockType( {\n            mergeToBlock: true,\n            toText(block:LineItemBlock) {\n                return '```\\n' + linesToText(block.items, true) + '```'\n            }\n        })\n        static LIST = new BlockType( {\n            mergeToBlock: true,\n            mergeFollowingNonTypedItemsWithSmallDistance: true,\n            toText(block:LineItemBlock) {\n                return linesToText(block.items, false);\n            }\n        })\n        static PARAGRAPH = new BlockType( {\n            toText(block:LineItemBlock) {\n                return linesToText(block.items, false);\n            }\n        })\n    */\n    static _ = BlockType.closeEnum()\n}\n\n\nexport function isHeadline(type: BlockType) {\n    return type && type.enumKey.length == 2 && type.enumKey[0] === 'H'\n}\n\nconst  formatTextDetectingTrailingSpaces = ( text:string, prefix:string, suffix?:string ) =>  {\n    if( !suffix ) suffix = prefix\n    const rx = /^(.+[^\\s]?)(\\s*)$/.exec(text)\n    return ( rx ) ? `${prefix}${rx[1]}${suffix}${rx[2]}` : 'null'\n}\n\nexport default class WordFormat extends Enumify {\n\n    constructor( public toText:ToText ) { super() }\n\n    static BOLD             = new WordFormat( ( text ) => formatTextDetectingTrailingSpaces(text, '**') )\n\n    static OBLIQUE          = new WordFormat( ( text ) => formatTextDetectingTrailingSpaces(text, '_') )\n\n    static BOLD_OBLIQUE     = new WordFormat( ( text ) => formatTextDetectingTrailingSpaces(text, '**_', '_**') )\n\n    static MONOSPACE        = new WordFormat( ( text ) => formatTextDetectingTrailingSpaces(text, '`') )\n\n    static _ = WordFormat.closeEnum()\n}\n\n// export function blockToText(block: LineItemBlock) {\n//     if (!block.type) {\n//         return linesToText(block.items, false);\n//     }\n//     return block.type.toText(block);\n// }\n\n/**\n * \n * @param level \n */\nfunction blockTypeByLevel(level: number):BlockType {\n\n    const blockType = BlockType.enumValues.find( e => e.enumKey == `H${level}` ) \n\n    //assert( blockType, `Unsupported headline level: ${level} (supported are 1-6)`)\n\n    if( !blockType ) {\n        console.warn( `Unsupported headline level: ${level} (supported are 1-6)` )\n        return BlockType.OVERFLOW\n    }\n\n    return blockType as BlockType\n}\n\n/**\n * \n * @param row \n * @param globals \n */\nfunction detectHeaders(row: Row) {\n\n    if (row.enhancedText.length == 1) {\n\n        const mostUsedHeight = globals.stats.mostUsedTextHeight\n\n        const etext = row.enhancedText[0];\n\n        if( etext.height != mostUsedHeight || etext.font != globals.stats.mostUsedFont ) {\n\n            const level = globals.stats.textHeigths.findIndex( v => v == etext.height ) \n            assert( level >=0 , `height ${etext.height} not present in textHeights stats!` )\n\n            const blockType = blockTypeByLevel( level+1 )\n            \n            etext.addTransformer(blockType.toText);\n\n        }\n    }\n\n}\n\nfunction detectFonts(row: Row ) {\n\n    row.enhancedText.forEach( etext => {\n\n        const fontId    = etext.font\n        const font      = globals.getFont( fontId )\n\n        if (font && font.name != null /*&& fontId != globals.stats.mostUsedFont*/ ) {\n\n            const fontName = font.name.toLowerCase()\n            \n            // console.log( `font['${fontId}']=${fontName}` )\n\n            const isBold = () => fontName.includes('bold')\n            const isItalic = () => fontName.includes('oblique') || fontName.includes('italic')\n            const isCode = () => fontName.includes('monospace') || fontName.includes('code')\n            \n            if (isBold() && isItalic() ) {\n                etext.addTransformer( WordFormat.BOLD_OBLIQUE.toText )              \n            } else if (isBold()) {\n                etext.addTransformer( WordFormat.BOLD.toText )\n            } else if ( isItalic() ) {\n                etext.addTransformer( WordFormat.OBLIQUE.toText );\n            } else if (isCode()) {\n                etext.addTransformer( WordFormat.MONOSPACE.toText )\n            } else if (fontName === globals.stats.maxHeightFont) {\n                etext.addTransformer( WordFormat.BOLD_OBLIQUE.toText )\n            } \n        }\n\n    })\n}\n\n// class Stack<T> {\n//     private _values = Array<T>();\n\n//     push( value:T ) {\n//         this._values.push(value);\n//     }\n//     peek():T|undefined {\n//         if(this._values.length>0) {\n//             return this._values[ this._values.length-1 ]\n//         } \n//     }\n//     pop():T|undefined {\n//         if(this._values.length>0) {\n//             return this._values.shift()\n//         }\n//     }\n// }\n\ntype CodeBlock = {\n    start:number; \n    end:number \n    word:Word} \n\nfunction detectCodeBlock(page: Page) {\n\n    const codeFontId = globals.getFontIdByName('monospace') || globals.getFontIdByName('code')\n    if( !codeFontId ) {\n        console.warn(`monospace or code font doesn't exists!`)\n        return; // GUARD\n    }\n\n    // console.debug( `page.rows:${page.rows.length}, codeFontId:${codeFontId}`)\n\n    const candidateToBeInCodeBlock = (row:Row) => \n            ( row.containsWords && row.enhancedText.length == 1 && row.enhancedText[0].font == codeFontId ) \n\n    const codeBlocks = Array<CodeBlock>()\n\n    let currentCodeBlock:CodeBlock|null = null ;\n\n    page.rows.forEach( (row, index ) => {\n\n        if( candidateToBeInCodeBlock(row) ) {\n\n            const word = row.enhancedText[0]\n\n            if( currentCodeBlock==null ) {\n                currentCodeBlock = { start:index, end:index, word:{ ...word, text:'`'} }\n            }\n            else {\n                currentCodeBlock.end = index\n            }\n        }\n        else {\n            if( currentCodeBlock!=null && currentCodeBlock.end > currentCodeBlock.start ) {\n                // console.log( `Codeblock detected: { start:${currentCodeBlock.start}; end:${currentCodeBlock.end} }`)\n                currentCodeBlock.end = index\n                codeBlocks.push( currentCodeBlock )\n            }\n            currentCodeBlock = null\n        }\n    })\n\n    let offset = 0;\n    codeBlocks.forEach( cb => {\n\n        for( let ii = cb.start + offset; ii < cb.end + offset; ++ii) {\n            page.rows[ii].enhancedText[0].addTransformer( (text) => text )\n        }\n        page.insertRow( cb.start    + offset++, cb.word )\n        page.insertRow( cb.end      + offset++, cb.word )\n\n    })\n}\n\nexport function toMarkdown(page: Page ) {\n    // const pageContainsMaxHeight = \n    //     page.rows.filter(row => \n    //         row.containsWords).findIndex(row => row.containsTextWithHeight(globals.stats.maxTextHeight)) >= 0\n\n    detectCodeBlock(page)\n\n    const init = ''\n\n    return page.rows.reduce((result, row, i) => {\n\n        let md = ''\n        if ( row.images ) {\n            md = row.images.reduce ( (out, img) => \n                    out.concat(`![${img.url}](${globals.imageUrlPrefix}${img.url}.png)`) , '') \n        }\n        if (row.containsWords) {\n\n            detectHeaders(row )         \n            detectFonts( row )\n\n            md = row.enhancedText.reduce((out, etext) => out.concat(etext.toMarkdown()), '')\n        }\n\n        return result.concat(md).concat('\\n')\n\n    }, init)\n\n} ","import 'pdfjs-dist/es5/build/pdf.js';\nimport fs from 'fs'\nimport path from 'path'\n\nimport { promisify } from 'util'\n\nimport { getDocument } from 'pdfjs-dist'\n\nimport { processPage, Page } from './pdf2md.page';\nimport { toMarkdown } from './pdf2md.markdown';\nimport { globals } from './pdf2md.global';\n\n// Some PDFs need external cmaps.\nconst CMAP_URL = \"../../../node_modules/pdfjs-dist/cmaps/\";\nconst CMAP_PACKED = true;\n\nconst readFile = promisify(fs.readFile)\nconst writeFile = promisify(fs.writeFile)\n\n\n/**\n * \n * @param pdfPath \n */\nexport async function pdfToMarkdown(pdfPath: string) {\n\n  try {\n\n    const basename = path.basename(pdfPath, '.pdf')\n\n    const fontFile  = path.join(globals.outDir, `${basename}.fonts.json`)\n    const outFile   = path.join(globals.outDir, `${basename}.md`)\n\n    globals.loadLocalFonts( fontFile )\n    \n    const data = new Uint8Array(await readFile(pdfPath))\n \n    const pdfDocument = await getDocument({\n      data: data,\n      cMapUrl: CMAP_URL,\n      cMapPacked: CMAP_PACKED\n    }).promise\n\n    const numPages = pdfDocument.numPages\n\n    const pages = Array<Page>(numPages)\n    \n    //const originalMetadata = await pdfDocument.getMetadata()\n\n    for (let i = 1; i <= numPages; i++) {\n    //for (let i = 9; i <= 9; i++) {\n\n      // Get the first page.\n      const pdfPage = await pdfDocument.getPage(i)\n\n      const page = await processPage( pdfPage )\n\n      pages.push( page )\n\n    }\n\n    const content = pages.map( page => toMarkdown( page ) )\n                          .reduce( (result, pageText ) => result.concat(pageText), '')\n\n    await writeFile( outFile, content )\n\n    globals.saveFonts( fontFile )\n\n    if( globals.options.debug ) {\n      pages.forEach( p => p.consoleLog() )\n    }\n\n    if( globals.options.stats ) {\n      globals.consoleLog()\n    }\n\n  }\n  catch (reason) {\n    console.log(reason)\n  }\n}\n","import 'pdfjs-dist/es5/build/pdf.js';\nimport fs from 'fs'\nimport { promisify } from 'util'\nimport path from 'path';\n\nimport { getDocument, OPS, PDFImage } from 'pdfjs-dist'\nimport { writePageAsImage, writePageImageOrReuseOneFromCache } from './pdf2md.image';\nimport { globals } from './pdf2md.global';\n\n// Some PDFs need external cmaps.\nconst CMAP_URL = \"../../../node_modules/pdfjs-dist/cmaps/\";\nconst CMAP_PACKED = true;\n\nconst readFile = promisify(fs.readFile)\nconst checkFileExistsAsync = promisify(fs.access)\nconst mkdirAsync = promisify(fs.mkdir)\n\n/**\n * \n * @param path \n */\nasync function createFolderIfDoesntExist(path: string) {\n\n  assert(path, `provided path is not valid`)\n\n  try {\n    await checkFileExistsAsync(path)\n  }\n  catch (e) {\n    console.log(`folder ${path} doesn't exist, try to create`)\n    await mkdirAsync(path)\n  }\n\n  return path\n}\n\n/**\n * \n * @param pdfPath \n */\nasync function extractImagesfromPages(pdfPath: string) {\n\n  try {\n\n    const data = new Uint8Array(await readFile(pdfPath))\n\n    const pdfDocument = await getDocument({\n      data: data,\n      cMapUrl: CMAP_URL,\n      cMapPacked: CMAP_PACKED,\n    }).promise\n\n    // const metadata = await pdfDocument.getMetadata()\n\n    const pages = pdfDocument.numPages;\n\n    for (let i = 1; i <= pages; i++) {\n\n      // Get the first page.\n      const page = await pdfDocument.getPage(i)\n\n      const ops = await page.getOperatorList()\n\n      for (let j = 0; j < ops.fnArray.length; j++) {\n\n        if (ops.fnArray[j] == OPS.paintJpegXObject || ops.fnArray[j] == OPS.paintImageXObject) {\n\n          const op = ops.argsArray[j][0];\n\n          const img = page.objs.get(op) as PDFImage;\n\n          //const scale = img.width / page._pageInfo.view[2];\n\n          await writePageImageOrReuseOneFromCache(img, op)\n          // await writePageAsImage( page )\n\n        }\n\n      }\n\n    }\n  }\n  catch (reason) {\n    console.log(reason)\n  }\n}\n\n\n/**\n * \n * @param pdfPath \n */\nasync function savePagesAsImages(pdfPath: string) {\n\n  try {\n\n    const data = new Uint8Array(await readFile(pdfPath))\n\n    const pdfDocument = await getDocument({\n      data: data,\n      cMapUrl: CMAP_URL,\n      cMapPacked: CMAP_PACKED,\n    }).promise\n\n    // const metadata = await pdfDocument.getMetadata()\n\n    const pages = pdfDocument.numPages;\n\n    for (let i = 1; i <= pages; i++) {\n\n      // Get the first page.\n      const page = await pdfDocument.getPage(i)\n\n      await writePageAsImage(page)\n\n\n    }\n  }\n  catch (reason) {\n    console.log(reason)\n  }\n}\n\n// STARTUP CODE\nimport { program } from 'commander'\nimport { assert } from 'console';\nimport { pdfToMarkdown } from './pdf2md.main';\n\nexport async function run() {\n\n  const choosePath = ( pdfPath:any, cmdobj:any ) => \n              ( cmdobj.parent.outdir ) ? \n                            cmdobj.parent.outdir : \n                            path.basename(pdfPath, '.pdf')\n\n  program.version('0.2.0')\n    .name('pdftools')\n    .option('-o, --outdir [folder]', 'output folder')\n\n    program.command('pdfximages <pdf>')\n      .description('extract images (as png) from pdf and save it to the given folder')\n      .alias('pxi')\n      .action( async (pdfPath, cmdobj) => {\n\n        globals.outDir = await createFolderIfDoesntExist(choosePath( pdfPath, cmdobj))\n        \n        return extractImagesfromPages(pdfPath)\n      })\n      ;\n\n    program.command('pdf2images <pdf>')\n      .description('create an image (as png) for each pdf page')\n      .alias('p2i')\n      .action(async (pdfPath, cmdobj) => {\n\n        globals.outDir = await createFolderIfDoesntExist(choosePath( pdfPath, cmdobj))\n\n        return savePagesAsImages(pdfPath)\n      })\n      ;\n\n      program.command('pdf2md <pdf>')\n      .description('convert pdf to markdown format.')\n      .alias('p2md')\n      .option('--imageurl [url prefix]', 'imgage url prefix')\n      .option('--stats', 'print stats information')\n      .option('--debug', 'print debug information')\n      .action(async (pdfPath, cmdobj) => {\n\n        globals.outDir = await createFolderIfDoesntExist(choosePath( pdfPath, cmdobj))\n\n        if( cmdobj.imageurl) {\n          globals.imageUrlPrefix = cmdobj.imageurl\n        }\n\n        globals.options.debug = cmdobj.debug\n        globals.options.stats = cmdobj.stats\n      \n        //console.log( options )\n\n        await pdfToMarkdown(pdfPath)\n      })\n    ;\n\n    // program.on('--help', () => {\n\n    //   program.commands.forEach( cmd => {\n    //     console.log( '=========================================================')\n    //     cmd.outputHelp()   \n    //   })\n\n    // });\n\n  return await program.parseAsync(process.argv)\n}\n"]}